<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iCalSyncHub - Calendar Viewer</title>
  <link href="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.css" rel="stylesheet" />
  <style>
    /* Make the page fill the viewport and use a column flex layout so the calendar can scroll inside without clipping */
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: Arial, sans-serif; display: flex; flex-direction: column; min-height: 100vh; }
    #top { padding: 0.75rem 1rem; background: #f3f4f6; border-bottom: 1px solid #e5e7eb; flex: 0 0 auto; }
    /* Make the site title non-selectable to avoid accidentally including it when copying the URL */
    #top strong { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    #info { user-select: text; -webkit-user-select: text; }
    /* Prevent copy button label from being selected when dragging or copying */
    #copyIcsBtn { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    /* Allow the calendar itself to scroll internally if needed, use remaining height, and be responsive/full-width */
    #calendar {
      /* Use flexbox sizing to avoid brittle calc() math and prevent clipping inside flex containers. Setting min-height:0
         allows the internal scrollbar to appear and not grow the parent, which is a common flexbox scrolling pitfall. */
      flex: 1 1 auto;
      min-height: 0;
      width: 100%;
      max-width: 1400px; /* cap to avoid ultra-wide layouts */
      margin: 0 auto;
      box-sizing: border-box;
      padding: 1rem;
      overflow-y: auto;
      overflow-x: hidden;
      /* Reserve stable gutter for scrollbars so they don't overlay the rightmost day column in month view */
      scrollbar-gutter: stable;
      -webkit-overflow-scrolling: touch;
    }

    /* Keep small screens consistent */
    @media (max-width: 600px) {
      /* On small screens we reduce padding */
      #calendar { padding: 0.5rem; }
    }

    /* Fallback for older browsers that don't support `scrollbar-gutter` */
    @supports not (scrollbar-gutter: stable) {
      #calendar { padding-right: 16px; }
    }

    /* Ensure day numbers and top-of-cell content sit above any scrollbars or adjacent elements */
    .fc .fc-daygrid-day-top {
      position: relative;
      z-index: 2;
    }

    /* Ensure the FullCalendar grid doesn't create its own overlapping scroll area; allow the container scrollbar to be the primary scroller */
    .fc .fc-scrollgrid, .fc .fc-daygrid-body {
      overflow: visible !important;
    }
  </style>
</head>
<body>
  <div id="top">
    <strong>iCalSyncHub Viewer</strong>
    <span id="info" style="margin-left:1rem;color:#555"></span>
  </div>
  <div id="calendar"></div>

  <!--INJECT_EVENT_COLOR_MAP-->

  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ical.js@1.4.0/build/ical.min.js"></script>
  <script>
    // Helper: compute readable text color (#000 or #fff) for a background hex color
    function readableTextColor(hex) {
      try {
        if (!hex) return '#000000';
        hex = hex.replace('#','');
        if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
        const r = parseInt(hex.slice(0,2),16);
        const g = parseInt(hex.slice(2,4),16);
        const b = parseInt(hex.slice(4,6),16);
        // Perceived luminance
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        return lum > 128 ? '#000000' : '#ffffff';
      } catch (e) {
        return '#000000';
      }
    }

    // Determine token/filename from the current path (e.g., /<token>.html)
    (async function(){
      try {
        // Ensure FullCalendar is loaded (fallback to CDN loader if blocked)
        async function ensureScript(url){
          return new Promise((resolve,reject)=>{
            const s = document.createElement('script');
            s.src = url;
            s.onload = () => resolve();
            s.onerror = () => reject(new Error('Failed to load ' + url));
            document.head.appendChild(s);
          });
        }
        if (typeof FullCalendar === 'undefined'){
          // try loading a compatible UMD build
          await ensureScript('https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js');
          if (typeof FullCalendar === 'undefined') throw new Error('FullCalendar is not available after fallback load.');
        }
        const path = window.location.pathname;
        const token = path.split('/').pop().replace('.html','');
        const icsUrl = `${token}.ics`;
        // Display full absolute ICS URL (including domain) as plain text so users can import it into their client.
        const absoluteIcsUrl = new URL(icsUrl, window.location.href).toString();
        const infoEl = document.getElementById('info');
        infoEl.textContent = absoluteIcsUrl;
        // Add a small copy-to-clipboard button that copies only the ICS URL (avoids copying the site title)
        const copyBtn = document.createElement('button');
        copyBtn.id = 'copyIcsBtn';
        copyBtn.type = 'button';
        copyBtn.textContent = 'Copy';
        copyBtn.setAttribute('aria-label', 'Copy ICS URL');
        copyBtn.style.marginLeft = '0.5rem';
        copyBtn.style.padding = '0.15rem 0.5rem';
        copyBtn.style.fontSize = '0.9rem';
        copyBtn.style.cursor = 'pointer';
        copyBtn.style.border = '1px solid #cbd5e1';
        copyBtn.style.borderRadius = '4px';
        copyBtn.style.background = '#fff';
        copyBtn.style.color = '#111827';
        // Ensure the button label cannot be selected (extra safeguard for browsers)
        copyBtn.style.userSelect = 'none';
        copyBtn.setAttribute('unselectable', 'on');
        copyBtn.onselectstart = () => false;
        copyBtn.addEventListener('click', async () => {
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(absoluteIcsUrl);
            } else {
              const ta = document.createElement('textarea');
              ta.value = absoluteIcsUrl;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand('copy');
              document.body.removeChild(ta);
            }
            copyBtn.textContent = 'Copied!';
            setTimeout(() => copyBtn.textContent = 'Copy', 2000);
          } catch (e) {
            console.error('Copy failed', e);
            copyBtn.textContent = 'Error';
            setTimeout(() => copyBtn.textContent = 'Copy', 2000);
          }
        });
        infoEl.appendChild(copyBtn);

        const resp = await fetch(icsUrl);
        if (!resp.ok) throw new Error('Failed to fetch ICS: ' + resp.status);
        const icsText = await resp.text();

        // Client-side normalization to reduce faulty VEVENTs (ported from tools/simulate_normalizer.py)
        function normalizeIcs(s) {
          try {
            // Unfold lines
            s = s.replace(/\r?\n[ \t]+/g, '');

            // Remove broken TZID fragments that contain spaces, commas, or parentheses (e.g., "TZID=(UTC+01:00) Amsterdam, Berlin,...")
            // This turns e.g. "DTSTART;TZID=(UTC+01:00) Amsterdam, Berlin:20260105T131500" into "DTSTART:20260105T131500"
            s = s.replace(/^(DTSTART|DTEND|EXDATE|RECURRENCE-ID);TZID="?[^:\r\n\"]*[ \t,\(\)][^:\r\n\"]*"?:/gim, '$1:');

            // Also strip stray alphabetic fragments that may remain before the colon (e.g., "DTEND;TZID=... Ams:2026...")
            s = s.replace(/^(DTSTART|DTEND|EXDATE|RECURRENCE-ID)(;[^:]*)?\s+[A-Za-z]{1,10}(?=:\d)/gim, '$1');

            // Normalize date property lines to ensure the value after the colon is a clean date/time token.
            // This picks the last date-like token on the line (handles folded or messy TZID prefixes).
            s = s.replace(/^(DTSTART[^:]*|DTEND[^:]*|EXDATE[^:]*|RECURRENCE-ID[^:]*):(.*)$/gim, (m, prop, rest) => {
              try {
                const matches = (rest || '').match(/(\d{8}T\d{6}Z?|\d{8})/g);
                if (matches && matches.length) return `${prop}:${matches[matches.length-1]}`;
                return `${prop}:${(rest||'').replace(/\s+/g,'')}`;
              } catch (e) { return m; }
            });

            // AM/PM normalization: handle only date-time property lines (DTSTART/DTEND/EXDATE/RECURRENCE-ID)
            // Convert forms like "YYYY-MM-DD 9:00 AM", "YYYYMMDDT090000 AM", or compact "YYYYMMDDT090000Am" into canonical YYYYMMDDTHHMMSS.
            // First handle compact 6-digit time tokens optionally followed by AM/PM (e.g., "20260117T090000Am" or "2026-01-17T090000 AM").
            s = s.replace(/^(DTSTART[^:]*:|DTEND[^:]*:|EXDATE[^:]*:|RECURRENCE-ID[^:]*:)(\d{8}T)(\d{6})(?:\s*(AM|PM))?/gim,
                          (m, prop, datePrefix, time6, ampm) => {
              try {
                let hh = time6.slice(0,2);
                const mm = time6.slice(2,4);
                const ss = time6.slice(4,6);
                if (ampm) {
                  const upper = (ampm || '').toUpperCase();
                  let hour = parseInt(hh, 10);
                  if (upper === 'PM' && hour < 12) hour += 12;
                  if (upper === 'AM' && hour === 12) hour = 0;
                  hh = String(hour).padStart(2, '0');
                }
                return `${prop}${datePrefix}${hh}${mm}${ss}`;
              } catch (e) { return m; }
            });

            // Also handle hyphenated ISO date with compact time and optional AM/PM (e.g., "2026-01-17T090000Am")
            s = s.replace(/^(DTSTART[^:]*:|DTEND[^:]*:|EXDATE[^:]*:|RECURRENCE-ID[^:]*:)(\d{4}-\d{2}-\d{2}T)(\d{6})(?:\s*(AM|PM))?/gim,
                          (m, prop, datePrefix, time6, ampm) => {
              try {
                let hh = time6.slice(0,2);
                const mm = time6.slice(2,4);
                const ss = time6.slice(4,6);
                if (ampm) {
                  const upper = (ampm || '').toUpperCase();
                  let hour = parseInt(hh, 10);
                  if (upper === 'PM' && hour < 12) hour += 12;
                  if (upper === 'AM' && hour === 12) hour = 0;
                  hh = String(hour).padStart(2, '0');
                }
                const dateBase = datePrefix.replace(/T$/, '').replace(/-/g, '');
                return `${prop}${dateBase}T${hh}${mm}${ss}`;
              } catch (e) { return m; }
            });

            // Fallback: handle colon-form times like "9:00 AM" or "09:00AM"
            s = s.replace(/^(DTSTART[^:]*:|DTEND[^:]*:|EXDATE[^:]*:|RECURRENCE-ID[^:]*:)(\d{4}-\d{2}-\d{2}T|\d{8}T|\d{4}-\d{2}-\d{2} )(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)/gim,
                    (m, prop, datePrefix, h, mnt, sec, ampm) => {
              try {
                const hour = parseInt(h, 10);
                const upper = (ampm || '').toUpperCase();
                let newHour = hour % 12;
                if (upper === 'PM') newHour += 12;
                if (hour === 12 && upper === 'AM') newHour = 0;
                const hh = String(newHour).padStart(2, '0');
                const ssec = sec || '00';
                // Normalize date base to YYYYMMDD
                let dateBase = datePrefix.replace(/T$/, '').trim();
                if (dateBase.indexOf('-') !== -1) dateBase = dateBase.replace(/-/g, '');
                return `${prop}${dateBase}T${hh}${mnt}${ssec}`;
              } catch (e) {
                return m;
              }
            });

            // Strip stray AM/PM tokens that might still remain at end of property values (e.g., "DTSTART:20260117T090000Am")
            s = s.replace(/^(DTSTART[^:]*:)(.*?)(?:\s*(AM|PM))$/gim, (m, prop, val) => {
              return `${prop}${val}`;
            });

            // Handle TZID with UTC offsets or city names for DTSTART/DTEND/EXDATE/RECURRENCE-ID
            const tzCityMap = ['Amsterdam','Berlin','Vienna','Rome','Stockholm','London','Paris','Zurich','Bern'];
            s = s.replace(/^(DTSTART|DTEND|EXDATE|RECURRENCE-ID)(;TZID="?([^";:\r\n]+)"?)?:(.*)$/gim, (m, prop, tzParam, tz, val) => {
              if (!tz) return `${prop}:${val}`;
              const off = tz.match(/UTC\s*([+-]\d{2}):?(\d{2})?/i);
              if (off) {
                // Convert date-times with UTC offset to Z-formatted UTC timestamps when possible
                try {
                  const parts = val.split(',');
                  const out = parts.map(dt => {
                    if (/^\d{8}$/.test(dt)) return dt; // date-only
                    const mdt = dt.match(/^(\d{8}T\d{6})/);
                    if (!mdt) return dt;
                    const sdt = mdt[1];
                    const y = parseInt(sdt.slice(0,4),10);
                    const mo = parseInt(sdt.slice(4,6),10);
                    const d = parseInt(sdt.slice(6,8),10);
                    const hh = parseInt(sdt.slice(9,11),10);
                    const mm = parseInt(sdt.slice(11,13),10);
                    const ss = parseInt(sdt.slice(13,15),10);
                    const sign = off[1].startsWith('-') ? -1 : 1;
                    const oh = parseInt(off[1].slice(1,3),10);
                    const om = parseInt(off[2] || '0',10);
                    const offsetMinutes = sign * (oh*60 + om);
                    const dtObj = new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
                    // shift by offset to UTC
                    const utcMs = dtObj.getTime() - offsetMinutes*60*1000;
                    const utc = new Date(utcMs);
                    const YYYY = utc.getUTCFullYear();
                    const MM = String(utc.getUTCMonth()+1).padStart(2,'0');
                    const DD = String(utc.getUTCDate()).padStart(2,'0');
                    const H = String(utc.getUTCHours()).padStart(2,'0');
                    const Min = String(utc.getUTCMinutes()).padStart(2,'0');
                    const S = String(utc.getUTCSeconds()).padStart(2,'0');
                    return `${YYYY}${MM}${DD}T${H}${Min}${S}Z`;
                  });
                  return `${prop}:${out.join(',')}`;
                } catch (e) {
                  return `${prop}:${val}`;
                }
              }
              const found = tzCityMap.find(c => tz.indexOf(c) !== -1);
              if (found) return `${prop};TZID=Europe/${found}:${val}`;
              // Last resort: drop the TZID and keep the value
              return `${prop}:${val}`;
            });

            // Remove remaining bad TZID params that contain spaces, commas, or parentheses
            s = s.replace(/;TZID="?[^:\r\n\"]*[ \t,\(\)][^:\r\n\"]*"?/g, '');

            // Fix colon folds (where colon moved to next folded line)
            s = s.replace(/\r?\n\s*:/g, ':');

            return s;
          } catch (e) {
            console.warn('Normalization failed', e);
            return s;
          }
        }

        const normalizedIcs = normalizeIcs(icsText);
        // Ensure `comp` is available in the outer scope so later code can reference it even if parsing falls back
        let comp = null;
        try {
          // Try parsing normalized text; fallback to raw if parse fails
          let beforeCount = null;
          try { const cb = new ICAL.Component(ICAL.parse(icsText)); beforeCount = cb.getAllSubcomponents('vevent').length; } catch(e){}
          const jcal = ICAL.parse(normalizedIcs);
          comp = new ICAL.Component(jcal);
          try { const ca = new ICAL.Component(ICAL.parse(normalizedIcs)); console.info('VEVENTs parsed: before=%s after=%s', beforeCount === null ? 'unknown' : beforeCount, ca.getAllSubcomponents('vevent').length); } catch(e){}
        } catch (err) {
          // If normalized parse fails, attempt raw parse for diagnostics
          try {
            const jcal = ICAL.parse(icsText);
            comp = new ICAL.Component(jcal);
            console.info('VEVENTs parsed (raw only) =', comp.getAllSubcomponents('vevent').length);
          } catch (err2) {
            throw err; // rethrow the original normalized parse error
          }
        }
        // 'comp' variable is defined (or null if both parses failed); we keep using that as before.

        // Build VEVENTs safely: skip faulty events and collect diagnostic info
        const _totalVevents = comp.getAllSubcomponents('vevent').length;
        let _skippedNoStart = 0;
        let _skippedException = 0;
        const _skippedNoStartSamples = [];
        const _skippedExceptionSamples = [];

        const vevents = comp.getAllSubcomponents('vevent').map(ev => {
          try {
            const e = new ICAL.Event(ev);

            // Ensure we have a valid start date; if not, treat as faulty and skip (record sample)
            const start = e.startDate ? e.startDate.toJSDate().toISOString() : null;
            if (!start) {
              _skippedNoStart++;
              const uid = ev.getFirstPropertyValue('uid') || '(no-uid)';
              const summary = (ev.getFirstPropertyValue('x-orig-summary') || e.summary || '').toString();
              if (_skippedNoStartSamples.length < 10) _skippedNoStartSamples.push({ uid, summary });
              return null;
            }

            // Prefer original summary preserved by the anonymizer; fall back to event summary
            const origSummary = ev.getFirstPropertyValue('x-orig-summary') || e.summary || '';

            // Resolve color from injected EVENT_COLOR_MAP (keys are matched case-sensitively first, then lowercased)
            let color = null;
            if (typeof window.EVENT_COLOR_MAP !== 'undefined' && origSummary) {
              color = window.EVENT_COLOR_MAP[origSummary] || window.EVENT_COLOR_MAP[(origSummary || '').toLowerCase()] || null;
            }

            // fallback to VEVENT property X-COLOR or COLOR
            if (!color) {
              color = ev.getFirstPropertyValue('x-color') || ev.getFirstPropertyValue('color') || null;
            }

            const backgroundColor = color || null;
            const textColor = color ? readableTextColor(color) : null;

            // FullCalendar accepts ISO strings and color properties
            return {
              title: e.summary || '',
              start: start,
              end: e.endDate ? e.endDate.toJSDate().toISOString() : null,
              backgroundColor: backgroundColor,
              borderColor: backgroundColor,
              textColor: textColor
            };
          } catch (err) {
            // Non-fatal: skip this VEVENT and record sample for debugging
            _skippedException++;
            const uid = ev.getFirstPropertyValue('uid') || '(no-uid)';
            const summary = (ev.getFirstPropertyValue('x-orig-summary') || ev.getFirstPropertyValue('summary') || '').toString();
            if (_skippedExceptionSamples.length < 10) _skippedExceptionSamples.push({ uid, summary, error: (err && err.message) || String(err) });
            console.warn('Skipping faulty VEVENT:', uid, summary, err);
            return null;
          }
        }).filter(e => e && e.start);

        const _includedEvents = vevents.length;

        const calendar = new FullCalendar.Calendar(document.getElementById('calendar'), {
          initialView: 'timeGridWeek',
          firstDay: 1, // Monday as first day of week
          height: '100%',
          headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,timeGridWeek,timeGridDay' },
          // Header formatting per view:
          dayHeaderContent: function(arg) {
            try {
              const viewType = (arg.view && arg.view.type) ? arg.view.type.toLowerCase() : '';
              const date = arg.date;

              // Month view: short weekday name with first letter capitalized (e.g., 'Sun', 'Mon')
              if (viewType.indexOf('month') !== -1) {
                const short = date.toLocaleDateString(undefined, { weekday: 'short' });
                return { html: String(short).charAt(0).toUpperCase() + String(short).slice(1).toLowerCase() };
              }

              // Week view: short weekday name with first letter capitalized (e.g., 'Sun', 'Mon') and day number (e.g., 'Monday 25')
              if (viewType.indexOf('week') !== -1) {
                const weekday = date.toLocaleDateString(undefined, { weekday: 'short' });
                const d = date.getDate();
                return { html: `${weekday.charAt(0).toUpperCase() + weekday.slice(1).toLowerCase()} ${d}` };
              }

              // Day view: full weekday name only (e.g., 'Monday')
              if (viewType.indexOf('day') !== -1) {
                const weekday = date.toLocaleDateString(undefined, { weekday: 'long' });
                return { html: weekday };
              }

              // Fallback: short weekday
              const fallback = date.toLocaleDateString(undefined, { weekday: 'short' });
              return { html: fallback };
            } catch (e) {
              return { html: '' };
            }
          },
          events: vevents,
          // Show event times in 24-hour format (no AM/PM)
          eventTimeFormat: { hour: '2-digit', minute: '2-digit', hour12: false },
          // Ensure the time grid slot labels (left column in week/day views) use 24-hour format as well
          slotLabelFormat: { hour: '2-digit', minute: '2-digit', hour12: false }
        });
        calendar.render();

        // If any VEVENTs were skipped due to being faulty, show a small non-intrusive notice with breakdown
        const totalSkipped = _skippedNoStart + _skippedException;
        if (totalSkipped > 0) {
          const note = document.createElement('span');
          note.style.marginLeft = '0.75rem';
          note.style.color = '#b45309';
          note.style.fontSize = '0.9rem';
          note.textContent = ` (skipped ${totalSkipped} events: ${_skippedNoStart} no-start, ${_skippedException} parse errors)`;
          infoEl.appendChild(note);

          // Add a details button to show inline diagnostics (so users don't need DevTools)
          const detailsBtn = document.createElement('button');
          detailsBtn.type = 'button';
          detailsBtn.textContent = 'Details';
          detailsBtn.style.marginLeft = '0.5rem';
          detailsBtn.style.fontSize = '0.9rem';
          detailsBtn.style.cursor = 'pointer';
          detailsBtn.style.border = '1px solid #cbd5e1';
          detailsBtn.style.borderRadius = '4px';
          detailsBtn.style.padding = '0.15rem 0.5rem';
          detailsBtn.onclick = () => {
            debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
          };
          infoEl.appendChild(detailsBtn);

          // Inline debug panel (hidden by default)
          const debugPanel = document.createElement('div');
          debugPanel.style.marginTop = '0.5rem';
          debugPanel.style.padding = '0.75rem';
          debugPanel.style.background = '#fff7ed';
          debugPanel.style.border = '1px solid #f0ab00';
          debugPanel.style.borderRadius = '6px';
          debugPanel.style.color = '#92400e';
          debugPanel.style.fontSize = '0.9rem';
          debugPanel.style.display = 'none';
          debugPanel.id = 'ics-debug-panel';

          const summaryText = document.createElement('div');
          summaryText.textContent = `Parsed VEVENTs: total=${_totalVevents}, included=${_includedEvents}, skipped=${totalSkipped}`;
          debugPanel.appendChild(summaryText);

          if (_skippedNoStartSamples.length) {
            const h = document.createElement('div'); h.style.fontWeight = '600'; h.style.marginTop = '0.5rem'; h.textContent = `Samples (no-start, showing up to ${Math.min(50, _skippedNoStartSamples.length)}):`;
            debugPanel.appendChild(h);
            const ul = document.createElement('ul'); ul.style.margin = '0.25rem 0 0 1rem';
            _skippedNoStartSamples.slice(0,50).forEach(s => {
              const li = document.createElement('li'); li.textContent = `${s.uid} — ${s.summary}`; ul.appendChild(li);
            });
            debugPanel.appendChild(ul);
          }

          if (_skippedExceptionSamples.length) {
            const h2 = document.createElement('div'); h2.style.fontWeight = '600'; h2.style.marginTop = '0.5rem'; h2.textContent = `Samples (parse exceptions, showing up to ${Math.min(50, _skippedExceptionSamples.length)}):`;
            debugPanel.appendChild(h2);
            const ul2 = document.createElement('ul'); ul2.style.margin = '0.25rem 0 0 1rem';
            _skippedExceptionSamples.slice(0,50).forEach(s => {
              const li = document.createElement('li'); li.textContent = `${s.uid} — ${s.summary} — ${s.error}`; ul2.appendChild(li);
            });
            debugPanel.appendChild(ul2);
          }

          // Download JSON button for full samples (helps offline debugging)
          const dlBtn = document.createElement('button');
          dlBtn.type = 'button';
          dlBtn.textContent = 'Download debug JSON';
          dlBtn.style.marginTop = '0.5rem';
          dlBtn.style.fontSize = '0.9rem';
          dlBtn.style.cursor = 'pointer';
          dlBtn.style.border = '1px solid #cbd5e1';
          dlBtn.style.borderRadius = '4px';
          dlBtn.style.padding = '0.15rem 0.5rem';
          dlBtn.onclick = () => {
            const payload = {
              total: _totalVevents,
              included: _includedEvents,
              skipped_no_start: _skippedNoStart,
              skipped_exceptions: _skippedException,
              samples_no_start: _skippedNoStartSamples,
              samples_exceptions: _skippedExceptionSamples
            };
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `${token}_ics_debug.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          };
          debugPanel.appendChild(dlBtn);

          infoEl.appendChild(debugPanel);

          // Console diagnostics (limited samples) to help troubleshoot why events were skipped
          console.info(`Parsed VEVENTs: total=${_totalVevents}, included=${_includedEvents}, skipped=${totalSkipped}`);
          if (_skippedNoStartSamples.length) console.info('Samples of events skipped (no start):', _skippedNoStartSamples);
          if (_skippedExceptionSamples.length) console.info('Samples of events skipped (exceptions):', _skippedExceptionSamples);
        }
      } catch (err) {
        document.body.innerHTML = `<div style="padding:1rem; color:#900">Error loading calendar: ${err}</div>`;
      }
    })();
  </script>
</body>
</html>
